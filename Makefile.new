# Makefile for Mini Linux Shell
# 目标环境：Linux
# 编译器：GCC

CC = gcc
CFLAGS = -Wall -Wextra -g -std=c11
LDFLAGS =

# 目录定义
SRC_DIR = src
CMD_DIR = $(SRC_DIR)/commands
BIN_DIR = bin
SCRIPT_DIR = scripts

# 主Shell程序
SHELL_MAIN = $(SRC_DIR)/shell_main.c
SHELL_BIN = $(BIN_DIR)/mini_shell

# C命令程序列表
CMD_SOURCES = $(wildcard $(CMD_DIR)/*.c)
CMD_BINS = $(patsubst $(CMD_DIR)/%.c,$(BIN_DIR)/%,$(CMD_SOURCES))

# Shell脚本列表
SHELL_SCRIPTS = $(wildcard $(SCRIPT_DIR)/*.sh)
SHELL_BINS = $(patsubst $(SCRIPT_DIR)/%.sh,$(BIN_DIR)/%,$(SHELL_SCRIPTS))

# 所有目标
ALL_BINS = $(SHELL_BIN) $(CMD_BINS)

# 默认目标
.PHONY: all
all: directories $(ALL_BINS) scripts
	@echo "========================================="
	@echo "编译完成！"
	@echo "========================================="
	@echo "主程序: $(SHELL_BIN)"
	@echo "命令程序: $(BIN_DIR)/mytouch, mycat, mycp, ..."
	@echo "Shell脚本: $(BIN_DIR)/*.sh"
	@echo ""
	@echo "运行方式:"
	@echo "  ./$(SHELL_BIN)"
	@echo "========================================="

# 创建目录
.PHONY: directories
directories:
	@mkdir -p $(BIN_DIR)

# 编译主Shell程序
$(SHELL_BIN): $(SHELL_MAIN)
	@echo "编译主Shell程序: $@"
	$(CC) $(CFLAGS) -o $@ $< $(LDFLAGS)

# 编译C命令程序
$(BIN_DIR)/%: $(CMD_DIR)/%.c
	@echo "编译命令: $@"
	$(CC) $(CFLAGS) -o $@ $< $(LDFLAGS)

# 复制Shell脚本到bin目录并添加执行权限
.PHONY: scripts
scripts: $(SHELL_SCRIPTS)
	@echo "复制Shell脚本到 $(BIN_DIR)/"
	@for script in $(SHELL_SCRIPTS); do \
		base=$$(basename $$script); \
		cp $$script $(BIN_DIR)/$$base; \
		chmod +x $(BIN_DIR)/$$base; \
		echo "  - $$base"; \
	done

# 清理编译产物
.PHONY: clean
clean:
	@echo "清理编译产物..."
	rm -rf $(BIN_DIR)
	@echo "清理完成。"

# 重新编译
.PHONY: rebuild
rebuild: clean all

# 安装（可选，将程序安装到系统路径）
.PHONY: install
install: all
	@echo "安装程序到 /usr/local/bin/"
	sudo cp $(SHELL_BIN) /usr/local/bin/
	sudo cp $(CMD_BINS) /usr/local/bin/
	sudo cp $(BIN_DIR)/*.sh /usr/local/bin/
	@echo "安装完成。"

# 卸载
.PHONY: uninstall
uninstall:
	@echo "卸载程序..."
	sudo rm -f /usr/local/bin/mini_shell
	sudo rm -f /usr/local/bin/mytouch
	sudo rm -f /usr/local/bin/mycat
	sudo rm -f /usr/local/bin/mycp
	sudo rm -f /usr/local/bin/myrm
	sudo rm -f /usr/local/bin/mychmod
	sudo rm -f /usr/local/bin/myls
	sudo rm -f /usr/local/bin/myps
	sudo rm -f /usr/local/bin/mykill
	sudo rm -f /usr/local/bin/myhistory
	sudo rm -f /usr/local/bin/create_user.sh
	sudo rm -f /usr/local/bin/delete_user.sh
	sudo rm -f /usr/local/bin/change_password.sh
	@echo "卸载完成。"

# 运行Shell
.PHONY: run
run: all
	@echo "启动Mini Linux Shell..."
	@$(SHELL_BIN)

# 测试编译（仅编译，不链接）
.PHONY: test-compile
test-compile:
	@echo "测试编译所有源文件..."
	@for src in $(SHELL_MAIN) $(CMD_SOURCES); do \
		echo "测试: $$src"; \
		$(CC) $(CFLAGS) -c $$src -o /dev/null; \
	done
	@echo "测试编译完成。"

# 显示帮助
.PHONY: help
help:
	@echo "========================================="
	@echo "Mini Linux Shell - Makefile帮助"
	@echo "========================================="
	@echo "可用目标："
	@echo "  make          - 编译所有程序（默认）"
	@echo "  make all      - 编译所有程序"
	@echo "  make clean    - 清理编译产物"
	@echo "  make rebuild  - 重新编译"
	@echo "  make run      - 编译并运行Shell"
	@echo "  make install  - 安装到系统"
	@echo "  make uninstall - 从系统卸载"
	@echo "  make test-compile - 测试编译"
	@echo "  make help     - 显示此帮助信息"
	@echo "========================================="

# 依赖关系（可选，用于增量编译）
# 说明：不要为一组具体目标写出包含“%.c”的普通依赖，
# 否则 Make 会把 “src/commands/%.c” 当成真实文件路径，
# 导致 “没有规则可制作目标 src/commands/%.c” 的构建错误。
$(SHELL_BIN): $(SHELL_MAIN)

